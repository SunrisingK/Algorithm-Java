序列动态规划（Sequence Dynamic Programming）是动态规划（DP）的一个重要分支，专门用于解决与**序列（如数组、字符串）相关的问题**。其核心思想是通过将序列问题分解为若干个子问题，利用子问题的解推导出原问题的解，从而高效地解决具有重叠子问题和最优子结构的序列问题

### 核心特点

1. **状态定义与序列位置相关**通常以序列的索引（如 `i`、`j`）作为状态的核心参数，定义 `dp[i]` 或 `dp[i][j]` 表示“序列前 `i` 个元素”或“序列中第 `i` 到第 `j` 个元素”的子问题解。
2. **子问题依赖于序列的局部结构**状态转移方程通常基于序列中元素的相邻关系、位置关系或某种约束（如大小、匹配等）推导，例如：

   - `dp[i]` 可能依赖 `dp[i-1]`、`dp[i-2]`（相邻元素的子问题）；
   - `dp[i][j]` 可能依赖 `dp[i+1][j]`、`dp[i][j-1]` 或 `dp[i+1][j-1]`（区间内的子问题）。
3. **适用场景**主要解决序列相关的优化问题，例如：

   - 最长递增子序列（LIS）、最长公共子序列（LCS）；
   - 字符串编辑距离、回文子串/子序列问题；
   - 序列分割、拼接或按规则计数（如解码方法）等

### 基本步骤

1. **定义状态**根据问题目标，确定 `dp` 数组的含义。例如：

   - 对于“最长递增子序列”，定义 `dp[i]` 为“以第 `i` 个元素结尾的最长递增子序列长度”；
   - 对于“编辑距离”，定义 `dp[i][j]` 为“将字符串 `s` 的前 `i` 个字符转换为字符串 `t` 的前 `j` 个字符的最少操作数”。
2. **推导转移方程**分析子问题之间的关系，确定如何从已知的子问题解推出当前状态的解。例如：

   - 最长递增子序列中，若 `nums[i] > nums[j]`（`j < i`），则 `dp[i] = max(dp[i], dp[j] + 1)`；
   - 编辑距离中，若 `s[i-1] == t[j-1]`，则 `dp[i][j] = dp[i-1][j-1]`；否则可通过插入、删除、替换操作转移，取最小值。
3. **初始化边界条件**确定序列的起始状态（如空序列、单个元素的子问题）。例如：

   - 单个元素的最长递增子序列长度为 1（`dp[i] = 1` 初始值）；
   - 空字符串到长度为 `j` 的字符串的编辑距离为 `j`（需插入 `j` 次）。
4. **计算最终结果**根据状态定义，从 `dp` 数组中提取原问题的解。例如：

   - 最长递增子序列的结果是 `dp` 数组中的最大值；
   - 编辑距离的结果是 `dp[s.length()][t.length()]`
