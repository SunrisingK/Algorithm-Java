拓扑排序是对**有向无环图（DAG）** 的顶点进行排序的算法，排序后所有有向边都从排序靠前的顶点指向排序靠后的顶点，它能解决“依赖任务的执行顺序”类问题

这个算法的核心价值在于处理依赖关系，比如课程学习（先学高数再学线代）、项目任务安排（先设计再开发），你提的这个问题正好切中了图论在实际场景中的关键应用

### 核心概念与前提

1. **适用图类型**：仅适用于**有向无环图（DAG）**。若图中存在环（如“任务A依赖B，B依赖C，C依赖A”），则无法进行拓扑排序。
2. **排序结果**：不唯一。只要满足所有依赖关系，同一DAG可能有多种合法的拓扑序列
   - 示例：图中顶点为“起床（A）、刷牙（B）、洗脸（C）”，依赖关系是“A→B、A→C”，则拓扑序列可以是[A,B,C]，也可以是[A,C,B]

### 两种常见实现算法

#### 1. Kahn算法（基于入度）

这是最直观的算法，核心是“不断挑选入度为0的顶点”，步骤如下：

1. 计算所有顶点的**入度**（指向该顶点的边的数量），并将入度为0的顶点加入队列
2. 从队列中取出一个顶点，加入拓扑序列，并删除该顶点的所有出边
3. 对出边指向的顶点，将其入度减1；若入度变为0，加入队列
4. 重复步骤2-3，直到队列为空。若拓扑序列长度等于顶点总数，则排序成功；否则图中存在环，排序失败

#### 2. DFS深度优先搜索算法

核心是“先遍历完所有依赖顶点，再记录当前顶点”，步骤如下：

1. 对图中未访问的顶点，启动深度优先搜索（DFS）
2. 在DFS中，先递归遍历当前顶点的所有邻接顶点（即依赖的后续顶点）
3. 当当前顶点的所有邻接顶点都遍历完成后，将当前顶点加入栈（或列表）
4. 所有顶点遍历完成后，将栈中元素逆序输出，得到拓扑序列

#### 时间复杂度

Kahn算法和BFS实现的时间复杂度均为 O(V + E)

### 典型应用场景

- **任务调度**：项目开发中，确定“需求分析→UI设计→后端开发→前端开发→测试”的执行顺序。
- **课程安排**：大学选课系统中，确保先修课（如“数据结构”）在前，后续课（如“算法设计”）在后。
- **编译依赖**：编译器处理代码时，先编译被依赖的库文件，再编译引用该库的主程序。

---

### 例题

题目描述

某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N - 1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A 依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 <= A, B <= N - 1）。请编写一个算法，用于确定文件处理的顺序。

输入描述

第一行输入两个正整数 N, M。表示 N 个文件之间拥有 M 条依赖关系。

后续 M 行，每行两个正整数 S 和 T，表示 T 文件依赖于 S 文件。

输出描述

输出共一行，如果能处理成功，则输出文件顺序，用空格隔开。

如果不能成功处理（相互依赖），则输出 -1。

输入示例

```
5 4
0 1
0 2
1 3
2 4
```

输出示例

```
0 1 2 3 4
```

提示信息

文件依赖关系如下：

![](https://kamacoder.com/upload/kamacoder.com/image/20240430/20240430150745_18459.png)

所以，文件处理的顺序除了示例中的顺序，还存在

0 2 4 1 3

0 2 1 3 4

等等合法的顺序

数据范围：

0 <= N <= 10 ^ 5

1 <= M <= 10 ^ 9

每行末尾无空格
